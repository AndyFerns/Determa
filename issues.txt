1. Variable Re-Assignment is Missing
The Issue: You can declare a variable (var x = 10;), but you cannot change it (x = 20;).

Evidence:

include/ast.h defines NODE_VAR_ASSIGN.

src/parser.c has no logic to parse assignments. parse_statement only looks for print or an expression.

If you try to write x = 20;, the parser will treat it as an expression x (VarAccess), stop at the =, and throw an error: Expected ';' after expression.

Impact: Currently, all variables in Determa are effectively constants.

2. Block Scopes are Missing
The Issue: A "C-like" language relies on curly braces { ... } to define scope. Determa currently only supports a flat, global list of statements.

Evidence:

src/symbol.c implements symbol_table_enter_scope and symbol_table_exit_scope (The logic exists!).

src/typechecker.c never calls these functions. It initializes the table once and frees it at the end.

src/parser.c has no logic to parse { or }.

Impact: You cannot implement if statements, while loops, or functions correctly in the future without this.

3. Missing Data Types (String & Bool)
The Issue: Your types.h defines TYPE_BOOL and TYPE_STRING, but you cannot actually use them.

Evidence:

Lexer: src/lexer.c does not have logic to parse string literals ("hello") or boolean keywords (true, false).

Token: include/token.h does not have TOKEN_STRING or TOKEN_TRUE/TOKEN_FALSE.

Impact: Determa is currently an Integer-only language.

4. Uninitialized Variables
The Issue: In C, you can write int x;. In Determa, var x; throws an error.

Evidence:

src/typechecker.c explicitly enforces: "Variable declaration requires initializer for type inference."

Impact: This is a design choice (Type Inference vs Explicit Types), but it differs from your "C-like" goal.